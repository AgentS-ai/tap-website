

Begin by creating a tap root directory structure:

  % tap generate root /path/to/root_dir
  % cd /path/to/root_dir
  
Make a task:

  % tap generate task sample/task

Test the task (in fact invokes the rake test task):
 
  % tap run test 
  
Get help for the task:

  % tap run -- sample/task --help

Make a configuration file for the task:

	% tap generate config sample/task

Run the task, setting the 'label' configuration and passing some inputs:
  
  % tap run -- sample/task --label=processing one two

Interact with the task using irb:

  % tap console
  irb(main):001:0>  app.run('sample/task', 'one')
    I[21:29:28]              input one
  => ...
  irb(main):002:0>
  
Package the task into an executable ("rubyscript2exe":http://rubyforge.org/projects/rubyscript2exe must be installed and may not work on platforms where rubyscript2exe is squirrelly, ie OS X)

  % tap generate package sample "run sample/task"
  % rubyscript2exe pkg/sample.rb

h1. The Tap Directory Structure

After running the above commands (excluding the package step), you will have a standard application directory structure looking like this:

  /path/to/root_dir
	|- Rakefile
	|- ReadMe.txt
	|- config
	|   `- sample
	|       `- task.yml
	|- lib
	|   `- sample
	|       `- task.rb
	|- tap.yml
	`- test
	    |- sample
	    |   `- task_test.rb
	    |- tap_test_helper.rb
	    `- tap_test_suite.rb
	
The directory structure is set for development, with tests and a Rakefile for common tasks.  In fact when you run 'tap run test' you're launching the test task from Rakefile.   As you may surmise from the repetition of 'sample/task', tap tries to lookup files associated with a task (configs, class definitions, etc) using the task name.  The default name for a Tap::Task class is based on the class name, so the lib and test files both bear the underscored version of Sample::Task.

Tap doesn't require this exact directory structure.  By default tap configures itself with tap.yml, which gives you a hook to do all sorts of interesting things.  Abbreviating one of these files:

	# Specify paths for directories relative to root (the working directory)
	directories:                  
	  lib: ../lib          
	  config: ../config

	# Specify options
	options:                      
	  debug: true

	# Map task names to task classes as needed
	map:
	  process: Sample::Task

	# Specify code to execute before and after Tap executes
	before: |
	  puts "Beginning execution!"

Working down the line, now tap expects to find the lib and config directories up one folder, runs in debug mode, and prints 'Beginning execution!' as it gets going.  Furthermore, the 'process' task now instantiates a Sample::Task.  Demonstrate this behavior by making a subdirectory like '/path/to/root_dir/sub_dir', add tap.yml as above, and run tap from there:

<pre><code>
  [from '/path/to/root_dir/sub_dir']

  % tap run -- sample/task --label="sample task" one -- process --label=process one
	Beginning execution!
	ctl-i prints information
	ctl-c interupts execution
	beginning run...
	  I[22:06:17]        sample task one
	  I[22:06:17]            process one
</code></pre>

Tap is configurable such that you can keep your directories pretty much anywhere; you can even specify gems from which to load tasks.  

h1. Using Tap Programmatically

h2. Tap::Task

A task is structured like this:
 
<pre><code>
  module Sample
    # == Description
    # This documentation is available in RDoc, as well as from the
    # command line, if you were to run it through tap, like this:
    #   % tap run -- sample/task --help
    #
    # === Usage
    # By default, usage info comes up as well...
    #
    class Task < Tap::Task

      # Configurations are defined like this.  In this format, 
      # this comment is used in generating customized RDoc
      # documenting the configurations and any accessors created
      # for them.  The default 'config' creates a config reader
      # and writer.

      # this is the RDoc comment
      config :label, "input"      #-- this is the command line comment 
    
      # Process receives each input from the command line
      # and can do arbitrary work to make an output.
		  def process(input)
		    # use log to record information
		    log label, input

		    # the return of process is the task output
		    "#{label}: #{input} was processed"
		  end
    end
  end
</code></pre>

Pretty straight-forward in the basics.  It's important to note how much documentation is available from the task class file.  Tap utilizes and extends RDoc to read and make this documentation available in the web documentation, as well as from the tap command.  The default Rakefile has the necessary modifications such that the extended documentation is available from the 'rdoc' task. 

  % tap run rdoc

__ Still Under Construction... __
* iteration

h2. Tap::FileTask

h2. Tap::App and Tap::Workflow

h2. Testing
